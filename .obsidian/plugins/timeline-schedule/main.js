/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/timestring/index.js
var require_timestring = __commonJS({
  "node_modules/timestring/index.js"(exports, module2) {
    module2.exports = parseTimestring;
    var DEFAULT_OPTS = {
      hoursPerDay: 24,
      daysPerWeek: 7,
      weeksPerMonth: 4,
      monthsPerYear: 12,
      daysPerYear: 365.25
    };
    var UNIT_MAP = {
      ms: ["ms", "milli", "millisecond", "milliseconds"],
      s: ["s", "sec", "secs", "second", "seconds"],
      m: ["m", "min", "mins", "minute", "minutes"],
      h: ["h", "hr", "hrs", "hour", "hours"],
      d: ["d", "day", "days"],
      w: ["w", "week", "weeks"],
      mth: ["mon", "mth", "mths", "month", "months"],
      y: ["y", "yr", "yrs", "year", "years"]
    };
    function parseTimestring(value, returnUnit, opts) {
      opts = Object.assign({}, DEFAULT_OPTS, opts || {});
      if (typeof value === "number" || value.match(/^[-+]?[0-9.]+$/g)) {
        value = parseInt(value) + "ms";
      }
      let totalSeconds = 0;
      const unitValues = getUnitValues(opts);
      const groups = value.toLowerCase().replace(/[^.\w+-]+/g, "").match(/[-+]?[0-9.]+[a-z]+/g);
      if (groups === null) {
        throw new Error(`The value [${value}] could not be parsed by timestring`);
      }
      groups.forEach((group) => {
        const value2 = group.match(/[0-9.]+/g)[0];
        const unit = group.match(/[a-z]+/g)[0];
        totalSeconds += getSeconds(value2, unit, unitValues);
      });
      if (returnUnit) {
        return convert(totalSeconds, returnUnit, unitValues);
      }
      return totalSeconds;
    }
    function getUnitValues(opts) {
      const unitValues = {
        ms: 1e-3,
        s: 1,
        m: 60,
        h: 3600
      };
      unitValues.d = opts.hoursPerDay * unitValues.h;
      unitValues.w = opts.daysPerWeek * unitValues.d;
      unitValues.mth = opts.daysPerYear / opts.monthsPerYear * unitValues.d;
      unitValues.y = opts.daysPerYear * unitValues.d;
      return unitValues;
    }
    function getUnitKey(unit) {
      for (const key of Object.keys(UNIT_MAP)) {
        if (UNIT_MAP[key].indexOf(unit) > -1) {
          return key;
        }
      }
      throw new Error(`The unit [${unit}] is not supported by timestring`);
    }
    function getSeconds(value, unit, unitValues) {
      return value * unitValues[getUnitKey(unit)];
    }
    function convert(value, unit, unitValues) {
      return value / unitValues[getUnitKey(unit)];
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimelineSchedule
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  blockVariableName: "schedule",
  startBlockName: "Start",
  endBlockName: "Finish",
  enablePrettyPreview: true,
  enableCodeblockTextAutofill: true,
  startDateFormat: "MM/DD/YY - hh:mm A",
  endDateFormat: "MM/DD/YY - hh:mm A",
  eventDateFormat: "h:mm A"
};
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  // On close, reload the plugin
  hide() {
    this.plugin.updateEditorProcessors();
    this.plugin.reloadPlugin();
  }
  display() {
    this.containerEl.empty();
    const codeBlockVariableName = new import_obsidian.Setting(this.containerEl).setName("Code block variable").setDesc(
      "The name of the code block variable to use for the plugin."
    ).addText((text) => {
      text.setPlaceholder(DEFAULT_SETTINGS.blockVariableName).setValue(this.plugin.settings.blockVariableName).onChange(async (value) => {
        this.plugin.settings.blockVariableName = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.onblur = () => {
        this.display();
      };
    });
    codeBlockVariableName.addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.blockVariableName = DEFAULT_SETTINGS.blockVariableName;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const startBlockName = new import_obsidian.Setting(this.containerEl).setName("Start block name").setDesc("The name of the start block.").addText((text) => {
      text.setPlaceholder(DEFAULT_SETTINGS.startBlockName).setValue(this.plugin.settings.startBlockName).onChange(async (value) => {
        this.plugin.settings.startBlockName = value;
        await this.plugin.saveSettings();
      });
    });
    startBlockName.addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.startBlockName = DEFAULT_SETTINGS.startBlockName;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const endBlockName = new import_obsidian.Setting(this.containerEl).setName("End block name").setDesc("The name of the end block.").addText((text) => {
      text.setPlaceholder(DEFAULT_SETTINGS.endBlockName).setValue(this.plugin.settings.endBlockName).onChange(async (value) => {
        this.plugin.settings.endBlockName = value;
        await this.plugin.saveSettings();
      });
    });
    endBlockName.addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.endBlockName = DEFAULT_SETTINGS.endBlockName;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(this.containerEl).setName("Pretty preview when cursor leaves").setDesc(
      `Pretty preview ${this.plugin.settings.blockVariableName || DEFAULT_SETTINGS.blockVariableName} code blocks when your cursor exits the code block`
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enablePrettyPreview).onChange(async (value) => {
        this.plugin.settings.enablePrettyPreview = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Enable code block text autofill").setDesc(
      `When in a multi-line ${this.plugin.settings.blockVariableName || DEFAULT_SETTINGS.blockVariableName} code block, dates will be prepended on each line.`
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableCodeblockTextAutofill).onChange(async (value) => {
        this.plugin.settings.enableCodeblockTextAutofill = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian.Setting(this.containerEl).setName("Date formats");
    const startDateFormatDesc = document.createDocumentFragment();
    startDateFormatDesc.append(
      createLink(
        startDateFormatDesc,
        "Syntax Reference",
        "https://momentjscom.readthedocs.io/en/latest/moment/04-displaying/01-format/"
      ),
      startDateFormatDesc.createEl("br"),
      `Current syntax looks like this: ${(0, import_obsidian.moment)().format(
        this.plugin.settings.startDateFormat || DEFAULT_SETTINGS.startDateFormat
      )}`
    );
    const startDateFormat = new import_obsidian.Setting(this.containerEl).setName("Start date format").setDesc(startDateFormatDesc).addMomentFormat((format) => {
      format.setDefaultFormat(DEFAULT_SETTINGS.startDateFormat).setPlaceholder(DEFAULT_SETTINGS.startDateFormat).setValue(this.plugin.settings.startDateFormat).onChange(async (value) => {
        this.plugin.settings.startDateFormat = value;
        await this.plugin.saveSettings();
      });
      format.inputEl.onblur = () => {
        this.display();
      };
    });
    startDateFormat.addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.startDateFormat = DEFAULT_SETTINGS.startDateFormat;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const endDateFormatDesc = document.createDocumentFragment();
    endDateFormatDesc.append(
      createLink(
        endDateFormatDesc,
        "Syntax Reference",
        "https://momentjscom.readthedocs.io/en/latest/moment/04-displaying/01-format/"
      ),
      startDateFormatDesc.createEl("br"),
      `Current syntax looks like this: ${(0, import_obsidian.moment)().format(
        this.plugin.settings.endDateFormat || DEFAULT_SETTINGS.endDateFormat
      )}`
    );
    const endDateFormat = new import_obsidian.Setting(this.containerEl).setName("End date format").setDesc(endDateFormatDesc).addMomentFormat((text) => {
      text.setDefaultFormat(DEFAULT_SETTINGS.endDateFormat).setPlaceholder(DEFAULT_SETTINGS.endDateFormat).setValue(this.plugin.settings.endDateFormat).onChange(async (value) => {
        this.plugin.settings.endDateFormat = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.onblur = () => {
        this.display();
      };
    });
    endDateFormat.addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.endDateFormat = DEFAULT_SETTINGS.endDateFormat;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const eventDateFormatDesc = document.createDocumentFragment();
    eventDateFormatDesc.append(
      createLink(
        eventDateFormatDesc,
        "Syntax Reference",
        "https://momentjscom.readthedocs.io/en/latest/moment/04-displaying/01-format/"
      ),
      startDateFormatDesc.createEl("br"),
      `Current syntax looks like this: ${(0, import_obsidian.moment)().format(
        this.plugin.settings.eventDateFormat || DEFAULT_SETTINGS.eventDateFormat
      )}`
    );
    const eventDateFormat = new import_obsidian.Setting(this.containerEl).setName("Event date format").setDesc(eventDateFormatDesc).addMomentFormat((text) => {
      text.setDefaultFormat(DEFAULT_SETTINGS.eventDateFormat).setPlaceholder(DEFAULT_SETTINGS.eventDateFormat).setValue(this.plugin.settings.eventDateFormat).onChange(async (value) => {
        this.plugin.settings.eventDateFormat = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.onblur = () => {
        this.display();
      };
    });
    eventDateFormat.addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        this.plugin.settings.eventDateFormat = DEFAULT_SETTINGS.eventDateFormat;
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
  async validate() {
    return true;
  }
};
function createLink(el, text, href) {
  const link = el.createEl("a", { text, href });
  return link;
}

// src/codeblock-autofill.ts
var import_view = require("@codemirror/view");
var import_obsidian3 = require("obsidian");
var import_timestring = __toESM(require_timestring());

// src/utils.ts
var import_obsidian2 = require("obsidian");
function getStartDateFromUserString(dateString, settings) {
  let startDate = (0, import_obsidian2.moment)(dateString);
  if (!(startDate == null ? void 0 : startDate.isValid())) {
    startDate = (0, import_obsidian2.moment)(dateString, settings.startDateFormat);
  }
  return startDate;
}
var matchBlockRegex = /^(\[.*\]:)(.*)/gi;
var matchHumanTimeRegex = /\(.*?\)(\s*?)$/gi;
var acceptedStartWords = ["start", "begin"];
function getAcceptableStartDateRegex(settings) {
  if (!acceptedStartWords.includes(settings.startBlockName.toLowerCase())) {
    acceptedStartWords.push(settings.startBlockName);
  }
  const regexString = acceptedStartWords.map((word) => `\\[?${word}\\]?:?`);
  return new RegExp(`(${regexString.join("|")})(.*)`, "gi");
}
function getEndDateBlockRegex(settings) {
  return new RegExp(`(\\[${settings.endBlockName}\\]:)(.*)`, "i");
}

// src/codeblock-autofill.ts
function codeblockAutofillPlugin(app, settings) {
  return import_view.ViewPlugin.fromClass(
    class TimelineScheduleExtension {
      constructor(view) {
        this.view = view;
        this.handleKeyEvent = this.handleKeyEvent.bind(this);
        this.view.dom.addEventListener("keydown", this.handleKeyEvent);
        this.initInstanceVars();
      }
      initInstanceVars() {
        this.codeBlockRegex = new RegExp(
          "(.*)?`{3}(" + settings.blockVariableName + "\\s*?)\\n([\\w\\s\\S]*?)`{3}",
          "gim"
        );
        this.startBlockName = `[${settings.startBlockName}]:`;
        this.endBlockName = `[${settings.endBlockName}]:`;
      }
      destroy() {
        this.view.dom.removeEventListener(
          "keydown",
          this.handleKeyEvent
        );
      }
      handleKeyEvent() {
        const doc = this.view.state.doc.toString();
        if (!doc) {
          return false;
        }
        const matches = [...doc.matchAll(this.codeBlockRegex)];
        for (const match of matches) {
          const [, beforeCodeBlock, blockName] = match || [];
          if (typeof match.index === "undefined" || match.index === null) {
            continue;
          }
          if ((blockName == null ? void 0 : blockName.trim()) !== settings.blockVariableName) {
            continue;
          }
          if ((beforeCodeBlock == null ? void 0 : beforeCodeBlock.length) && !beforeCodeBlock.match(/^(\s|>)*$/gi)) {
            continue;
          }
          this.processMatchingCodeBlock(match);
        }
        return true;
      }
      processMatchingCodeBlock(match) {
        var _a, _b, _c, _d, _e, _f;
        const beforeCodeBlockContents = (match == null ? void 0 : match[1]) || "";
        const innerIndex = match.index + 4 + settings.blockVariableName.length + beforeCodeBlockContents.length;
        let hasChanges = false;
        const innerContents = match == null ? void 0 : match[3];
        const splitLines = innerContents.trim().split("\n");
        if (!splitLines.length) {
          splitLines.push("");
        }
        if (splitLines.length === 1) {
          splitLines.push("");
        }
        if (splitLines.length === 2) {
          splitLines.push("");
        }
        let startTime;
        let elapsedMs = 0;
        for (let i = 0; i < splitLines.length; i++) {
          let line = splitLines[i].trim();
          if (line.startsWith(beforeCodeBlockContents)) {
            line = line.substring(beforeCodeBlockContents.length);
          }
          const lineMatches = (_a = [
            ...line.matchAll(matchBlockRegex)
          ]) == null ? void 0 : _a[0];
          const textBlock = (lineMatches == null ? void 0 : lineMatches[1]) || "";
          let textAfterColon = ((lineMatches == null ? void 0 : lineMatches[2]) || "").trim();
          if (i === 0 && textBlock !== this.startBlockName) {
            const [, startBlock, afterColonMatch] = ((_b = [
              ...line.matchAll(
                getAcceptableStartDateRegex(settings)
              )
            ]) == null ? void 0 : _b[0]) || [];
            if (startBlock && afterColonMatch) {
              textAfterColon = afterColonMatch;
            }
            if (textAfterColon) {
              startTime = getStartDateFromUserString(
                textAfterColon,
                settings
              );
              line = `${this.startBlockName} ${startTime.format(
                settings.startDateFormat
              )}`;
            } else {
              startTime = (0, import_obsidian3.moment)();
              line = `${this.startBlockName} ${startTime.format(
                settings.startDateFormat
              )}`;
            }
            hasChanges = true;
            splitLines[i] = line;
            continue;
          } else if (i === 0 && textBlock === this.startBlockName) {
            if (textAfterColon) {
              startTime = getStartDateFromUserString(
                textAfterColon,
                settings
              );
            }
            continue;
          }
          const isEarlyFinishBlock = textBlock === this.endBlockName && i < 2;
          if (isEarlyFinishBlock) {
            textAfterColon = "";
          }
          if (!textBlock || isEarlyFinishBlock || textBlock !== this.endBlockName) {
            let nextDate = (0, import_obsidian3.moment)(startTime);
            if (elapsedMs) {
              nextDate = nextDate.add(elapsedMs, "millisecond");
            }
            console.log(nextDate.format(settings.eventDateFormat));
            const timeBlockString = `[${nextDate.format(
              settings.eventDateFormat
            )}]:`;
            if (textBlock !== timeBlockString) {
              if (textBlock) {
                line = `${timeBlockString} ${textAfterColon}`;
              } else {
                if (timeBlockString.startsWith(line)) {
                  line = `${timeBlockString} `;
                } else {
                  line = `${timeBlockString} ${line}`;
                }
              }
              hasChanges = true;
              splitLines[i] = line;
            }
          }
          if (textBlock !== this.endBlockName) {
            const humanTime = textAfterColon.match(matchHumanTimeRegex);
            if (humanTime) {
              try {
                const ms = (0, import_timestring.default)(
                  (humanTime == null ? void 0 : humanTime[0]) || "",
                  "ms"
                );
                if (ms) {
                  elapsedMs += ms;
                }
              } catch (error) {
              }
            }
          }
          if (i === splitLines.length - 1) {
            let endDate = (0, import_obsidian3.moment)(startTime);
            if (elapsedMs) {
              endDate = endDate.add(elapsedMs, "millisecond");
            }
            const endBlockString = `${this.endBlockName} ${endDate.format(settings.endDateFormat)}`;
            if (line.trim() !== endBlockString) {
              hasChanges = true;
              splitLines[i] = endBlockString;
            }
          }
        }
        if (hasChanges) {
          const newContents = splitLines.join("\n") + "\n";
          const activeView = (_c = app == null ? void 0 : app.workspace) == null ? void 0 : _c.getActiveViewOfType(import_obsidian3.MarkdownView);
          const existingScroll = (_d = activeView == null ? void 0 : activeView.currentMode) == null ? void 0 : _d.getScroll();
          const existingCursor = this.getCursor();
          const changes = {
            from: innerIndex,
            to: innerIndex + innerContents.length,
            insert: newContents
          };
          this.view.dispatch(this.view.state.update({ changes }));
          const newCursorLine = this.view.state.doc.toString().split("\n")[existingCursor.line - 1];
          let bumpCursor = 0;
          if (newCursorLine) {
            const matches = (_e = [
              ...newCursorLine.matchAll(matchBlockRegex)
            ]) == null ? void 0 : _e[0];
            if ((matches == null ? void 0 : matches[2].trim()) === "") {
              bumpCursor = newCursorLine.length;
            }
          }
          if (existingCursor == null ? void 0 : existingCursor.ch) {
            this.view.dispatch(
              this.view.state.update({
                selection: {
                  anchor: existingCursor.ch + bumpCursor,
                  head: existingCursor.ch + bumpCursor
                }
              })
            );
          }
          if (existingScroll) {
            (_f = activeView == null ? void 0 : activeView.currentMode) == null ? void 0 : _f.applyScroll(existingScroll);
          }
        }
      }
      getCursor() {
        const ch = this.view.state.selection.ranges[0].head;
        const line = this.view.state.doc.lineAt(ch).number;
        return {
          ch,
          line
        };
      }
    }
  );
}

// src/pretty-preview.ts
var import_obsidian4 = require("obsidian");
var import_timestring2 = __toESM(require_timestring());
var PrettyPreview = class extends import_obsidian4.MarkdownRenderChild {
  constructor(containerEl, body, settings) {
    super(containerEl);
    this.body = body;
    this.settings = settings;
  }
  onload() {
    return this.addVirtualTimeBlocks();
  }
  // If no time blocks are in the text, add them to a body string
  addVirtualTimeBlocks() {
    var _a, _b;
    const lines = this.body.trim().split("\n");
    const newLines = [];
    const startRegex = getAcceptableStartDateRegex(this.settings);
    const endRegex = getEndDateBlockRegex(this.settings);
    let hasStartLine = false;
    let startDate;
    let elapsedMs = 0;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (!hasStartLine) {
        hasStartLine = true;
        const [, startBlock, startTime] = ((_a = [...line.matchAll(startRegex)]) == null ? void 0 : _a[0]) || [];
        if (startBlock) {
          if (startTime) {
            startDate = getStartDateFromUserString(
              startTime.trim(),
              this.settings
            );
          } else {
            startDate = (0, import_obsidian4.moment)();
          }
          newLines.push(
            `[${this.settings.startBlockName}]: ${startDate.format(
              this.settings.startDateFormat
            )}`
          );
          if (lines.length > 1) {
            continue;
          }
        } else {
          startDate = (0, import_obsidian4.moment)();
          newLines.push(
            `[${this.settings.startBlockName}]: ${startDate.format(
              this.settings.startDateFormat
            )}`
          );
        }
      }
      if (!startDate) {
        startDate = (0, import_obsidian4.moment)();
      }
      const nextDate = (0, import_obsidian4.moment)(startDate).add(elapsedMs, "millisecond");
      const humanTime = line.match(matchHumanTimeRegex);
      if (humanTime) {
        try {
          const ms = (0, import_timestring2.default)((humanTime == null ? void 0 : humanTime[0]) || "", "ms");
          if (ms) {
            elapsedMs += ms;
          }
        } catch (error) {
        }
      }
      const timeBlockString = `[${nextDate.format(
        this.settings.eventDateFormat
      )}]:`;
      const [, block, contents] = ((_b = [...line.matchAll(matchBlockRegex)]) == null ? void 0 : _b[0]) || [];
      if (block && contents.trim() === "" || line.match(endRegex)) {
      } else if (block) {
        newLines.push(`${timeBlockString} ${contents}`);
      } else {
        newLines.push(`${timeBlockString} ${line}`);
      }
      if (i === lines.length - 1) {
        const endDate = (0, import_obsidian4.moment)(startDate).add(elapsedMs, "millisecond");
        const endBlock = `[${this.settings.endBlockName}]: ${endDate.format(this.settings.endDateFormat)}`;
        newLines.push(endBlock);
      }
    }
    return this.renderPreviewFromTimeBlocks(newLines);
  }
  // Render the preview as if the time blocks are already in the text
  renderPreviewFromTimeBlocks(lines) {
    var _a;
    const listEl = this.containerEl.createEl("ul", {
      cls: "timeline-schedule-list"
    });
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const [, block, contents] = ((_a = [...line.matchAll(matchBlockRegex)]) == null ? void 0 : _a[0]) || [];
      if (block && contents.trim()) {
        let listItemClassName = "timeline-schedule-list-item";
        if (i === 0) {
          listItemClassName += " timeline-schedule-start";
        } else if (i === lines.length - 1) {
          listItemClassName += " timeline-schedule-end";
        }
        const listItem = this.containerEl.createEl("li", {
          cls: listItemClassName
        });
        listItem.appendChild(
          this.containerEl.createEl("span", {
            cls: "timeline-schedule-list-item-block",
            text: block.replace(/[[\]]/gi, "").trim().replace(/:$/, "")
          })
        );
        listItem.appendChild(
          this.containerEl.createEl("span", {
            cls: "timeline-schedule-list-item-contents",
            text: contents
          })
        );
        listEl.appendChild(listItem);
      }
    }
    this.containerEl.appendChild(listEl);
  }
};

// src/main.ts
var TimelineSchedule = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.reloadingPlugins = false;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    if (this.settings.enablePrettyPreview) {
      try {
        this.registerMarkdownCodeBlockProcessor(
          this.settings.blockVariableName,
          (source, el, ctx) => {
            if (source.trim()) {
              ctx.addChild(
                new PrettyPreview(el, source, this.settings)
              );
            }
          }
        );
      } catch (error) {
      }
    }
    if (this.settings.enableCodeblockTextAutofill) {
      this.activeExtension = [
        codeblockAutofillPlugin(this.app, this.settings)
      ];
      this.registerEditorExtension(this.activeExtension);
      this.registerEvent(
        this.app.workspace.on(
          "active-leaf-change",
          this.updateEditorProcessors.bind(this)
        )
      );
    }
  }
  // Since we can disable/enable modes that register and unregister extensions/processors in settings
  // We need to reload the plugin to unregister existing extensions/processors when settings are changed
  async reloadPlugin() {
    var _a;
    if (this.reloadingPlugins)
      return;
    this.reloadingPlugins = true;
    const plugins = this.app.plugins;
    if (!((_a = plugins == null ? void 0 : plugins.enabledPlugins) == null ? void 0 : _a.has(this.manifest.id)))
      return;
    await plugins.disablePlugin(this.manifest.id);
    try {
      await plugins.enablePlugin(this.manifest.id);
    } catch (error) {
    }
    this.reloadingPlugins = false;
  }
  // Replaces the current active editor extension with an updated one
  // Useful for updating extension args when we change view contexts and/or settings
  updateEditorProcessors() {
    var _a;
    if ((_a = this.activeExtension) == null ? void 0 : _a.length) {
      this.activeExtension.length = 0;
      this.activeExtension.push(
        codeblockAutofillPlugin(this.app, this.settings)
      );
      this.app.workspace.updateOptions();
    }
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
    const settings = this.settings;
    for (const key in this.settings) {
      if (settings[key] === void 0 || settings[key] === null || settings[key] === "") {
        this.settings[key] = DEFAULT_SETTINGS[key];
      }
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

/* nosourcemap */