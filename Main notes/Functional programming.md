**Tags:** [[Programming]] [[Maths]]

- **Monads**: They allow you to chain operations while secretly managing busy work behind the scenes. Monads have three components; a wrapper type, a wrapper function (also known as *return, pure* or *unit*), and a run function that runs the transformation on the argument (also called *bind, flatmap* and *>>=*) `>>=` this operator in haskell is used to feed a 'maybe' value into a function that captures a pattern we've seen multiple times in the code. 
- Eg. The Maybe Monad: it has the Maybe type constructor (something or nothing), a `return` function and a `>>=` (sequencing operator). `return` takes a thing of any type and converts it into a Maybe value (x -> Maybe x). It gives a bridge between the pure world of values (x) and the world of what could go wrong (Maybe x). Sequencing gives you a way of determining what to do with those possibilities and values, so in this example it 'joins' the sequence of actions that include the option to handle errors but to this *join* function whether there's an error or not doesn't matter, it doesn't see it.
- Eg. A mapping `ret : Y -> T(Y)` means Y is the portion of T(Y) for which there are no computational effects 
- It deals with **effect**, it gives you a uniform framework or thinking about the side effects of your program. It supports pure programming **with side effects**, it gives you a way to do impure things with a pure programming language. It's explicit about effects. It enables the creation of functions that work for any effect (effect polymorphism).
- **Other definition:** Monads are a design pattern for composing computations in a sequence. It has three components: A type constructor (like the `Maybe` type), and two operations, a `return` (or `pure`) which is a function that takes a value and puts it in the monadic context, and a `bind` (or `>>=`) function that takes a monadic value and a function that operates on the monadic value, applies the function to the monadic value and makes sure the function applied to the monadic value doesn't wrap it again. Think of a **Monad** as a **conveyor belt factory**:
- **`return`** is like the machine that takes a single item (a value) and places it onto a conveyor belt (the monadic context).
- **`bind`** is the entire process of taking a conveyor belt with an item on it, letting a worker (your function) process that item, and then putting the _new_ item back onto the _same_ conveyor belt. It makes sure you don't end up with a mess of nested conveyor belts.
- *bind* or *>>=* unwraps the constructor type and applies a function to its value. *pure* or *return* wraps the value into the constructor type.
- When we talk about chaining operations, it means that bind allows us to do that because it prevent us from having values nested in multiple wrapped constructor types which we can't do with a function that doesn't take an argument of that type.
- Using a monad to handle side effects is important because it allows you to maintain the benefits of pure functional programming—predictability, testability, and composability—even when your program needs to interact with the outside world.
- Monads don't perform the side effects themselves. Instead, they act as a "wrapper" for a **computation that will perform the side effect**.
- An `IO` monad, for instance, isn't a string of text; it's an **object that represents the act of reading a line of text**.
- A `Maybe` monad isn't the final value; it's a **computation that might produce a value or might not**.
![[Monads]]
- **Currying:** A function that normally takes multiple arguments, is provided with one argument and returns a new function that remembers that previous arguments, and subsequently until all arguments have been provided and the function returns the value. This can be used to easily create reusable functions that have the same idea but with small differences in number of parameters and results depending on the parameters it remembers. It also changes the function's signature. Eg. assume a function's signature is `Number -> Number -> Number`, this means that it takes two numbers and returns a number.. After currying (giving it the first argument only for example), it becomes `Number -> (Number -> Number)` which indicates that this function now takes a number parameter and returns a function that takes a number parameter and returns a number.
- **Functor:** a functor is a [design pattern](https://en.wikipedia.org/wiki/Design_pattern "Design pattern") inspired by [the definition from category theory](https://en.wikipedia.org/wiki/Functor "Functor") that allows one to apply a [function](https://en.wikipedia.org/wiki/Function_\(mathematics\) "Function (mathematics)") to values inside a [generic type](https://en.wikipedia.org/wiki/Generic_type "Generic type") without changing the structure of the generic type.