**Tags:** [[Programming]]

- Referential transparency (good): a referentially transparent function is a pure function, meaning it does not affect / is not affected by the global state (eg. a function that uses a global variable is affected by the global state, and if it changes it it affects the global state). Formally, referential transparency is the concept of a function giving the same output when provided identical input every single time while avoiding side effects. The point is to be able to replace the expression the function compute by the function call itself without changing anything else in the program, this allows for easier logic and code evolution.
- Immutability (good): a function that generates the modified input as a copy to output it instead of directly modifying the input. -> No side effects, always return the same results, easy to test in isolation. Also helps to rollback to a previous version of the data structure. Also allows parallel processing to improve speed and performance.
- Shared mutable state (bad): Different processes/threads have the permission to change the same data structure, this creates conflict.
- Persistent data structures (good): data structure that when making a new copy, only creates a new copy for the elements that changed, leaving the unchanged elements in the new copy as references to the old (unchanged) copy.
- Nesting (bad): to avoid nesting there are two ways; extraction which means extracting part of the function into its own function and calling it in the first one, and inversion which means putting the "unhappy case" (what you would usually put in the 'else') as the condition (the first 'if') and bring back the else block into the parent code block since the else is no longer needed. This is called "early return", because if the unhappy condition is met then we exit the function without checking the other condition, and if it is not met we don't need to check anything we simply execute the code of the happy case.
- Dependency injection (good): Helps decouple code by separating it into multiple components that we can then combine by passing them as arguments to each other.
- Allowing the code to be plugged and unplugged from a production environment helps create testing environments and alternate between the two without having to create unorganized test units in the production environment and have uncertainty and unpredictability in your code. Eg. this can be done using interfaces, where we define a "shape" that we can plug into our code and matches the production environment, and then we implement the testing environment to correspond to that shape so we can plug and unplug it.
- The maximum length of a function is inversely proportional to the complexity and indentation of that function. Never try to explain how your code works in a comment.
- To write performant code: understand the compiler of your language, understand the data structures available to you in that language.
- Reduce the size of your code, make methods and variables private or protected to reduce exposure (and potential bugs), minimize the lifetime of variables by minimizing their scope if possible (ie. passing copies as arguments diminishes the chances for side effects). Never use uninitialized variables.